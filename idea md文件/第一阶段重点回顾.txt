重点回顾
1.基础语法
   -- 分支结构：if...else
   -- 循环结构：for / while / do ... while
   -- 数组：就是想要多存放相同类型的数据
          数组一旦创建，长度不能改变
          遍历数组，按照下标遍历
          数组适合查询，不适合增删
   -- 面试题： & &&   | || 的区别
   
2.OOP
   -- 封装：通过private关键字来实现。
          好处是提高了程序的安全性，代码的复用性
   -- 继承：开始是为了提高代码的复用，让子类少些代码，把共性方法提取成父类
      -- 方法的重写：出现的意义就是为了修改父类的原有业务，要求是子类的方法声明和父类一样
      -- 方法重写并没有修改父类的原有功能(源码并没有该！)，修改的是子类的方法体，使用时也是用子类的
   -- 多态：统一了调用的标准。编译看左边，也就是所有的功能只能调用父类提供的
                          运行看右边，也就是如果出现了方法的重写，运行结果以子类为准
      -- 多态的好处：不关心具体的子类类型，把子类都看做父类来看，写出通用的代码
      -- 抽象类：由来是当子类继承了父类后，子类需要对方法体进行修改。
                这时，父类原来提供的方法体有点多余，我们在父类中干脆就不提供方法体了，具体的业务交给子类去做就可以。
                这时，父类就产生了没有方法体的方法，我们就把这个方法称之为抽象方法
         -- 如果一个类中，包含了抽象方法，那么这个类必须声明为一个抽象类
         -- 特点：是一个特殊的类，可以有普通方法，也可以有抽象方法
      -- 接口：是一个特殊的抽象类，因为接口中统统都是抽象方法。接口里的资源都有简写形式
         -- 接口里的变量会自动拼接 public final 变成一个常量
         -- 接口里的方法会自动拼接 public abstract 变成一个抽象方法
   -- 面试题：
      -- overload 和 override 的区别
      -- 抽象类和接口的区别
      -- this 和 super 的区别


3.API
   -- 常见工具类
      -- String的特点和常用方法，最好背记个
      -- StringBuffer/StringBuilder用来计算字符串的拼接
      -- BigDecimal 用来计算浮点数运算不精确的方案
      -- BigInteger 用来解决超大整数运算
      -- 日期类Dat/日期转换工具类SimpleDateformate
   -- IO
      -- 可以说时底层代码
      -- 是指相对于程序来讲的读取个写出的动作。程序读取数据，in的过程；程序写出数据，out的过程
      -- 读取流
         -- 字节读取流：InputStream FileInpuStream BufferedInputStream
         -- 字符读取流：Reader FileReader BufferReader
      -- 写出流
         -- 字节写出流：OutputStream FileOutpuStream BufferedOutputStream
         -- 字符写出流：Writer FileWriter BufferWriter PrintWriter
      -- 读取的代码
         -- BufferedInputStream in = new BufferedInputStream(new FileInpuStream())
         -- BufferReader in2 = new BufferReader(new FileReader())
         -- in.read();
      -- 写出的代码
   -- 集合
      -- 是因为目前我们可以存储多个数据，只不过要求数据类型一致，而且是使用数组来存
         但是数组长度一旦创建长度不能变，不灵活，所以就产生了很多集合
      -- Collection是集合中的顶级接口，提取了List和set接口的共性方法
      -- List接口：元素都有下标，元素可以重复，元素有序
         -- 拥有了Collection接口的功能的同时，也有自己的特有功能(提供了很多可以根据下标操作的api)
         -- ArrayList：底层维护了一个数组的结构，适合查询
         -- LinkedList：底层维护了一个链表的结构，适合增删
      -- set接口：元素没有下标，元素不可重复，元素无序
         -- 拥有了Collection接口的功能，并没有自己的特有方法
         -- Hashset：底层维护了一个哈希表/散列表。存放元素时，会根据hash算法计算应该存放的位置
            -- 如果想给set集合去重需要同时重写两个方法：hashcode和equals
         -- TreeSet：不常用
      -- map接口：维护的都是键值对，数据都有映射关系。和Collection接口没有任何继承结构
         -- HashMap：底层维护了一个哈希表/散列表。存放元素时，会根据hash算法计算应该存放的位置
            -- ！！原理：底层时通过hash算法运行元素的存储位置+使用了数组+链表的形式来实现的(最好把数据放在数组里)
                        但是存放数据时，如果多个元素放在了同一个位置，这时就形成了链表结构，并不适合查询 
         -- TreeMap：不常用
   -- 面试题：
      -- 集合和数组的区别
      -- == 和 equals 的区别
      -- 字节和字符的区别
      -- close 和 flush 的区别
      
4.多线程和Socket编程
   -- 多线程实现方式
      -- 多线程：实现高效的CPU，提高程序执行效率
      -- 实现方式：继承Thread类  实现Runnable接口
      -- 多线程编程中的难题：就是共享数据会有线程安全隐患，解决方法--同步锁
      -- 同步锁原理：把共享资源加锁，保证共享资源同一时刻只有一个线程在使用。保证数据安全，但是牺牲了效率
      -- 同步锁加哪？从问题开始处，到问题结束位置
      -- 同步锁对象？如果是使用了同步代码块，锁哪个对象都可以，只要是一个对象就行
                   使用了同步方法，锁对象默认是this
                   使用同步锁且共享资源是静态资源，只能用类的字节码对象来锁 
   -- 面试题：
      -- 线程和进程的区别
      -- 并发和并行的区别
      -- start 和 run 的区别
      -- 线程的几种状态
      -- 同步锁的原理


5.Socket编程
   -- 常用来在多个电脑之间完成网络的数据传输
   -- 通常由服务器端和客户端构成
      -- 服务器：开启服务，接收客户端的连接请求
      -- 客户端：给服务器发送数据，接收服务器响应的数据
   -- ServerSocket代表Socket编程的服务器端，可以在指定端口处等待客户的连接
   -- Socket代表Socket编程的客户端，可以连接指定的服务器，需要同时指定服务器的ip和端口号
   -- Socket连接成功之后，就形成了网络传输数据的通道，这个通道可以获取双向liu(I/O),相当于获取到了数据，因为数据都会抽象成流的形式在通道传递
   -- 把服务器端进行优化，使用多线程技术开始Socket编程的服务器端，提高服务器的吞吐量
   
     